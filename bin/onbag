#!/bin/bash
set -o pipefail
shopt -qs extglob

: ${ONBAG_OUTPUT_MARKER='{}'}
outputMarker="$ONBAG_OUTPUT_MARKER"
readonly EXIT_SIGNAL=125
readonly NOOP_SIGNAL=124

isOnChange=
if [ "$1" = --onchange ]; then
    shift
    isOnChange=t
    parentScriptPid="$1"; shift
    typeset -a runWithPromptPromptArgs=()
    if [ "$1" = --consumed-exit-status-file ]; then
	shift
	consumedExitStatusFilespec="$1"; shift
	if [ -r "$consumedExitStatusFilespec" ]; then
	    <"$consumedExitStatusFilespec" IFS=$'\n' read -r exitStatus
	    rm --force -- "$consumedExitStatusFilespec" 2>/dev/null
	    runWithPromptPromptArgs=(--initial-status "${exitStatus:-0}")
	fi
    fi
else
    if [ -z "$PGID" ]; then # No parent script has become the process group leader yet.
	pgid=$(($(ps -o pgid= -p "$$")))	# By defining this, we'll be killing subshell processes of this process group when we're done or interrupted. Any children with the same ambition will defer to us.
	if [ $$ -eq $pgid ]; then
	    export PGID=$pgid   # We are (already / after setsid) in our own process group, announce our leadership to any children, so that they don't become leaders themselves and thereby decouple themselves from our lifetime control.
	else
	    exec setsid --wait "${BASH_SOURCE[0]}" "$@" # Use setsid instead of set -m (...) to avoid having another subshell in between.
	fi
    fi
fi


printShortUsage()
{
    printf 'Usage: %q %s\n' "$(basename "$1")" '[-t|--transactional] [--ignore-existing] [-n|--count N|-1] [-i|--interval NUMBER[SUFFIX] [-l|--max-lines N] [-S|--stop-on-empty] [-s|--stop-on PATTERN] [-t|--stop-after TIMEOUT[SUFFIX]] [--print] [[--bare|--no-capture-output] [--prefix-command PC] [--prefix-command-command PCC] [--parallel [--rate-limit NUMBER[SUFFIX]]] [--exit-on-success|--exit-on-failure|--exit-on NUM] [--prepend-on-failure|--prepend-on NUM|--prepend-unless NUM [--prepend-before TEXT|--prepend-after TEXT]] [--append-on-failure|--append-on NUM|--append-unless NUM [--append-before TEXT|--append-after TEXT]] -c|--command "COMMANDLINE" | [--] SIMPLECOMMAND [...]] [-?|-h|--help]'
}
printUsage()
{
    # This is the short help when launched with no or incorrect arguments.
    # It is printed to stderr to avoid accidental processing.
    printShortUsage "$1" >&2
    printf >&2 '\nTry %q --help for more information.\n' "$(basename "$1")"
}
printLongUsage()
{
    # This is the long "man page" when launched with the help argument.
    # It is printed to stdout to allow paging with 'more'.
    cat <<HELPDESCRIPTION
Observe a special file for added output, consume it from the start (FIFO-style)
in order to perform an action with it.
HELPDESCRIPTION
    echo
    printShortUsage "$1"
    echo
    cat <<HELPTEXT
    --transactional|-t	Lock the special file during the access so that writes
			are serialized and concurrent reads can only happen
			while no write is under way. Pass this to ensure
			consistency in case there could ever be contention over
			the file.
    --ignore-existing	Do not immediately react on existing lines; only start
			consuming once an actual external change has been
			observed / only consume existing line(s) each INTERVAL.
    --print		Print the added output.
    --bare		Do not print a status line before and after launching
			the COMMAND.
    --no-capture-output	By default, no status line is printed if the COMMAND did
			not have any output, and failing parallel invocations
			without output are ignored altogether. This option turns
			this off and will print status lines (and consider
			parallel failures) even without output. Some
			(interactive) commands (like Vim) do not like having
			their output not connected to the terminal, and can be
			made to cooperate by passing this option.
    --command|-c CMD	Execute CMD as a command-line. The string $outputMarker is
			replaced by the added output. Multiple lines (via
			--max-lines) are passed as individual arguments.
    --prefix-command PC	Put PC (directly) in front of the COMMAND(s) given by
			(subsequent, but not previous) --command or
			SIMPLECOMMAND. This can be used to inject a wrapper
			command.
    --prefix-command-command PCC
			Put PCC (directly) in front of the COMMAND(s) given by
			(subsequent, but not previous) --command, and pass
			COMMAND via --command COMMAND to PCC. This can be used
			to inject a wrapper command that itself takes a
			--command argument.
			This is different than --prefix-command when COMMAND
			itself is a pipeline; here, the entire pipeline will be
			passed to PCC; whereas PC would only cover the first
			command inside the pipeline.
    --interval|-i INTERVAL[SUFFIX]
			Wait for INTERVAL seconds between observations of the
			special file. By default, any change is observed
			immediately.
    --max-lines|-l N	A maximum of N (default: 1) lines are consumed and
			passed to COMMAND at once (if available). The entire set
			of lines counts as one change (for --count).
    --stop-on-empty|-S	Stop once the special file becomes empty because of
			observed changes / is deleted. The consumption of
			existing line(s) alone does not trigger this; at least
			one change needs to have been observed.
    --stop-on|-s PATTERN
			Stop observing changes if the output (individual lines)
			matches PATTERN. When multiple lines are consumed, lines
			before the match are still processed, and lines after
			the match are put back into the special file. PATTERN is
			a Bash-style extended regular expression.
    --stop-after|-t TIMEOUT[SUFFIX]
			Stop observing if no lines have been added for
			TIMEOUT[SUFFIX]. This includes the time spent processing
			any existing line(s).
    --parallel		Instead of waiting for one COMMAND to finish before
			executing the next, run each one the moment the change
			is triggered. The default is sequential invocation.
    --rate-limit NUMBER[SUFFIX]
			Sleep for NUMBER[SUFFIX] before triggering the next
			parallel execution of COMMAND. This can avoid triggering
			too many simultaneous executions.
    --exit-on-success	Stop observing changes if COMMAND is successful.
    --exit-on-failure	Stop observing changes if COMMAND is unsuccessful.
    --exit-on NUM	Stop observing changes if COMMAND exits with NUM.
    --exit-unless NUM	Stop observing changes if COMMAND does not exit with
			NUM.
    --count|-n N	Stop observing changes after N changes. Output that is
			retried is not counted.
    -1			Stop observing after the first change. Output that is
			retried is not counted.
    --prepend-on-failure
			Return the output to the beginning of the special file
			(so it will be considered right next again!) if COMMAND
			is unsuccessful.
    --prepend-on NUM	Return the output to the beginning of the special file
			if COMMAND exits with NUM.
    --prepend-unless NUM
			Return the output to the beginning of the special file
			if COMMAND does not exit with NUM.
    --prepend-before TEXT
			Put TEXT before the prepended output.
    --prepend-after TEXT
			Put TEXT after the prepended output.
    --append-on-failure	Put back the output to the end of the special file if
			COMMAND is unsuccessful.
    --append-on NUM	Put back the output to the end of the special file if
			COMMAND exits with NUM.
    --append-unless NUM	Put back the output to the end of the special file if
			COMMAND does not exit with NUM.
    --append-before TEXT
			Put TEXT before the appended output.
    --append-after TEXT
			Put TEXT after the appended output.
SUFFIX may be 's' for seconds (the default), 'm' for minutes, 'h' for hours or
'd' for days.
Example:
HELPTEXT
    printf '%q %s\n' "$(basename "$1")" '--bare -l 5 -s STOP --append-on-failure -- wget {}'
}

timeToSeconds()
{
    case "$1" in
	+([0-9])?(s))   time="${1%s}";;
	+([0-9])m)	time=$((${1%m} * 60));;
	+([0-9])h)	time=$((${1%h} * 3600));;
	+([0-9])d)	time=$((${1%d} * 86400));;
	*)		printf >&2 "ERROR: Illegal ${2:-timeout}: %s\\n" "$1"; exit 2;;
    esac
    printf %s "$time"
}

typeset -a allArgs=("$@")
typeset -a bagArgs=()
isConsumeExisting=t
isParallel=
count=
interval=
maxLines=1
isStopOnEmpty=
stopPattern=
stopAfter=
rateLimit=
exitOn=
exitComparison=-eq
prependOn=
prependComparison=-eq
prependBeforeText=
prependAfterText=
appendBeforeText=
appendAfterText=
appendOn=
appendComparison=-eq
typeset -a commands=()
prefixCommand=
prefixCommandCommand=
isPrint=
isBare=
isCaptureOutput=t
typeset -a onchangeArgs=()
typeset -a onchangeExitOnArg=()
while [ $# -ne 0 ]
do
    case "$1" in
	--help|-h|-\?)	shift; printLongUsage "$0"; exit 0;;
	--transactional|-t)
			bagArgs+=("$1"); shift;;
	--ignore-existing)
			shift; isConsumeExisting=;;
	--count|-n)	shift; count="$1"; shift;;
	-1)		shift; count=1;;
	--exit-on-success)	shift; exitOn=0; exitComparison=-eq; onchangeExitOnArg=(--exit-on $EXIT_SIGNAL);;
	--exit-on-failure)	shift; exitOn=0; exitComparison=-ne; onchangeExitOnArg=(--exit-on $EXIT_SIGNAL);;
	--exit-on)		shift; exitOn="$1"; shift; exitComparison=-eq; onchangeExitOnArg=(--exit-on $EXIT_SIGNAL);;
	--exit-unless)		shift; exitOn="$1"; shift; exitComparison=-ne; onchangeExitOnArg=(--exit-on $EXIT_SIGNAL);;
	--prepend-on-failure)	shift; prependOn=0; prependComparison=-ne;;
	--prepend-on)		shift; prependOn="$1"; shift; prependComparison=-eq;;
	--prepend-unless)	shift; prependOn="$1"; shift; prependComparison=-ne;;
	--prepend-before)	shift; prependBeforeText="$1"; shift;;
	--prepend-after)	shift; prependAfterText="$1"; shift;;
	--append-on-failure)	shift; appendOn=0; appendComparison=-ne;;
	--append-on)		shift; appendOn="$1"; shift; appendComparison=-eq;;
	--append-unless)	shift; appendOn="$1"; shift; appendComparison=-ne;;
	--append-before)	shift; appendBeforeText="$1"; shift;;
	--append-after)		shift; appendAfterText="$1"; shift;;
	--parallel)	shift; isParallel=t;;
	--print)	shift; isPrint=t;;
	--bare)		shift; isBare=t;;
	--no-capture-output)
			shift; isCaptureOutput=;;
	--command|-c)	shift
			if [ -n "$prefixCommandCommand" ]; then
			    printf -v quotedCommand %q "$1"
			    printf -v escapedOutputMarker %q "$outputMarker" # %q escapes {}, we don't want that to have it interpolated later.
			    commands+=(${commands:+;} "${prefixCommandCommand} --command ${quotedCommand//"$escapedOutputMarker"/$outputMarker}")
			else
			    commands+=(${commands:+;} "${prefixCommand}$1")
			fi
			shift
			;;
	--prefix-command)
			shift; prefixCommand="$1"; shift;;
	--prefix-command-command)
			shift; prefixCommandCommand="$1"; shift;;
	--interval|-i)	shift; interval="$1"; shift;;
	--max-lines|-l)	shift; maxLines="$1"; shift;;
	--stop-on-empty|-S)
			shift; isStopOnEmpty=t; onchangeExitOnArg=(--exit-on $EXIT_SIGNAL);;
	--stop-on|-s)	shift; stopPattern="$1"; shift; onchangeExitOnArg=(--exit-on $EXIT_SIGNAL);;
	--stop-after|-t)
			onchangeArgs+=("$1" "$2"); shift
			stopAfter="$(timeToSeconds "$1")" || exit $?; shift
			;;
	--rate-limit)	shift; rateLimit="$1"; shift;;
	--)		shift; break;;
	-*)		{ echo "ERROR: Unknown option \"$1\"!"; echo; printUsage "$0"; } >&2; exit 2;;
	*)		break;;
    esac
done
if [ $# -ne 0 ]; then
    # Combine --command and SIMPLECOMMAND; need to quote SIMPLECOMMAND to
    # undo the effects of eval.
    printf -v quotedSimpleCommand '%q ' "$@"
    printf -v escapedOutputMarker %q "$outputMarker"
    commands+=(${commands:+;} "${prefixCommand}${quotedSimpleCommand//"$escapedOutputMarker"/$outputMarker}")	# %q escapes {}, we don't want that to have it interpolated later.
fi
if [ ! "$isPrint" ] && [ ! "$count" ] && [ ${#commands[@]} -eq 0 ]; then
    echo 'ERROR: Need to pass either -1|-n|--count to count changes, --print to show added lines, or -c|--command to execute a command.'
    echo
    printUsage "$0"
    exit 2
fi >&2
if [ -n "$exitOn" -a -n "$isParallel" ]; then
    # Need a marker file to signal stopping; a variable won't do.
    keepRunningMarkerFile=$(mktemp --tmpdir "$(basename -- "$0")-XXXXXX" 2>/dev/null || echo "${TEMP:-/tmp}/$(basename -- "$0").$$$RANDOM")
    touch "$keepRunningMarkerFile"
fi

# Don't show a prompt if nothing was printed; this would just waste screen
# space. Parallel execution is supposedly mostly used to control resource usage
# (e.g. just one instance via singleton or not too frequent actions via
# oncePer). In that case, ignore failing invocations altogether.
typeset -a runWithPromptArgs=(); [ "$isCaptureOutput" ] && runWithPromptArgs+=(--no-output-no-prompt)
if [ "$isParallel" ]; then
    [ "$isCaptureOutput" ] && runWithPromptArgs+=(--no-output-no-error)
    runWithPromptArgs+=(--no-count-on 99)
fi



let observedChanges=0
SECONDS=0

exitStatus=0
consumeExistingOutput()
{
    while :
    do
	runWithPromptPromptArgs[-1]=$exitStatus
	processBag
	local status=$?
	case $status in
	    $EXIT_SIGNAL)
		return 0;;
	    $NOOP_SIGNAL)
		[ -n "$stopAfter" ] && [ $SECONDS -ge $stopAfter ] && exit 0	# Consumption of existing output already has taken longer than TIMEOUT, bail out before even starting the observation.
		return 0    # No existing output, start the observation for changes.
		;;
	    *)
		let observedChanges+=1
		exitStatus=$status
		if [ "$count" ]; then
		    [ $observedChanges -ge $count ] && exit $exitStatus	# Consumption of existing output already exceeded the amount of [sets of] lines we should consume; bail out.
		fi
		;;
	esac
    done
}

pollForOutput()
{
    while :
    do
	[ "${interval:?}" = 0 ] || sleep "$interval"

	processBag
	case $? in
	    $EXIT_SIGNAL)
		return 0;;
	    $NOOP_SIGNAL)
		[ -n "$stopAfter" ] && [ $SECONDS -ge $stopAfter ] && break
		;;
	    *)
		let observedChanges+=1
		if [ "$count" ]; then
		    [ $observedChanges -ge $count ] && return 0
		fi
		SECONDS=0
		runWithPromptPromptArgs=()
		;;
	esac
    done
}

processBag()
{
    bag "${bagArgs[@]}" --pop --quiet --lines "$maxLines" | executeTrigger
    typeset -a result=("${PIPESTATUS[@]}")

    if [ ${result[0]} -eq 1 ] && [ "$isStopOnEmpty" ]; then
	# The bag is empty.
	return $EXIT_SIGNAL
    fi
    return ${result[1]}
}

executeTrigger()
{
    readarray -t lines
    [ ${#lines[@]} -eq 0 ] && return $NOOP_SIGNAL   # Because of the pipeline, we're also invoked if bag fails due to an empty bag.

    local signal=0
    if [ -n "$stopPattern" ]; then
	local line lineCnt=0
	for line in "${lines[@]}"
	do
	    let lineCnt+=1
	    if [[ "$line" =~ $stopPattern ]]; then
		# Optimization when no --max-lines configured.
		[ ${#lines[@]} -eq 1 ] && return $EXIT_SIGNAL

		# Need to process any previous read lines, and put back lines
		# after the stop line. Do the latter first.
		[ $lineCnt -lt ${#lines[@]} ] && bag "${bagArgs[@]}" --prepend -- "${lines[@]}"
		if [ $lineCnt -eq 1 ]; then
		    return $EXIT_SIGNAL
		else
		    lines=("${lines[@]:0:$((lineCnt-1))}")
		    signal=$EXIT_SIGNAL
		fi
		break
	    fi
	done
    fi


    [ "$isPrint" ] && printf '%s\n' "${lines[@]}"

    if [ ${#commands[@]} -ge 1 ]; then
	if [ -n "$exitOn" -a -n "$isParallel" -a ! -e "$keepRunningMarkerFile" ]; then
	    # The marker file is gone; this means we should not trigger anything
	    # new, and instead exit the script.
	    signal=$EXIT_SIGNAL
	else
	    [ "$rateLimit" ] && sleep "$rateLimit"
	    eval 'triggerCommand "${lines[@]}"' ${isParallel:+&}
	    signal=$?
	    lines=()
	fi

	# Put back any lines that have been read but haven't been processed.
	[ ${#lines[@]} -gt 0 ] && bag "${bagArgs[@]}" --prepend -- "${lines[@]}"
    fi

    return $signal
}

triggerCommand()
{
    local quotedLines; printf -v quotedLines '%q ' "$@"; quotedLines=${quotedLines% }

    typeset -a expandedCommands=("${commands[@]//"$outputMarker"/$quotedLines}")

    unset ONBAG_OUTPUT_MARKER
    if [ "$isBare" ]; then
	eval "${expandedCommands[@]}"
    else
	{ printf '%s ' "${expandedCommands[@]}"; printf '\n'; } | runWithPrompt "${runWithPromptPromptArgs[@]}" "${runWithPromptArgs[@]}" --comment "$observedChanges"
    fi <&6
    local exitStatus=$?
    local result=$exitStatus
    [ $exitStatus -eq $NOOP_SIGNAL -o $exitStatus -eq $EXIT_SIGNAL ] && result=0    # Don't allow the COMMAND's exit status to masquerade as a signal.

    if [ "$prependOn" ] && [ $exitStatus $prependComparison $prependOn ]; then
	[ -n "$prependAfterText" ] && bag "${bagArgs[@]}" --prepend -- "$prependAfterText"
	printf '%s\n' "$@" | bag "${bagArgs[@]}" --prepend
	[ -n "$prependBeforeText" ] && bag "${bagArgs[@]}" --prepend -- "$prependBeforeText"
	result=$NOOP_SIGNAL
    fi
    if [ "$appendOn" ] && [ $exitStatus $appendComparison $appendOn ]; then
	[ -n "$appendBeforeText" ] && bag "${bagArgs[@]}" --append -- "$appendBeforeText"
	printf '%s\n' "$@" | bag "${bagArgs[@]}" --append
	[ -n "$appendAfterText" ] && bag "${bagArgs[@]}" --append -- "$appendAfterText"
	result=$NOOP_SIGNAL
    fi
    if [ "$exitOn" ] && [ $exitStatus $exitComparison $exitOn ]; then
	[ "$isParallel" ] && kill -SIGUSR1 $$
	result=$EXIT_SIGNAL
    fi
    return $result
}

database()
{
    miniDB --base-type runtime --schema 'PID COUNT' --table onbag "$@"
}

if [ "$isOnChange" ]; then
    status=0
    while [ $status -ne $NOOP_SIGNAL -a $status -ne $EXIT_SIGNAL ]
    do
	[ -n "$count" ] && observedChanges="$(database --query $parentScriptPid --columns COUNT)" || observedChanges=''

	processBag
	status=$?

	if [ -n "$count" ] && [ $status -ne $NOOP_SIGNAL ] && [ -n "$observedChanges" ]; then
	    let observedChanges+=1
	    [ $observedChanges -ge $count ] && exit $EXIT_SIGNAL
	    database --update "$parentScriptPid	$observedChanges"
	fi
    done
    exit $status
fi


shutdown()
{
    if [ -e "$keepRunningMarkerFile" ]; then
	rm -f "$keepRunningMarkerFile"
	wait    # Wait for running jobs to finish; this avoids the "Terminated" message and exit status 143.
    fi
    exit 0
}
trap "shutdown" SIGUSR1
if [ -n "$pgid" ]; then
    trap "kill -- -$pgid" EXIT  # If we're the leader, kill subshell processes when the script exits.
else
    trap "jobs -p | xargs --no-run-if-empty kill --" EXIT  # Someone else is the leader; killing remaining jobs is all we can do here.
fi
exec 6<&0

typeset -a runWithPromptPromptArgs=()
if [ "$isConsumeExisting" ]; then
    runWithPromptPromptArgs=(--no-trailing-prompt --initial-status 0)
    consumeExistingOutput
    runWithPromptPromptArgs=(--initial-status ${exitStatus:-0})
fi

if [ -n "$interval" ]; then
    pollForOutput
else
    if [ -n "$count" ]; then
	# We cannot let onchange directly count the invocations via --count, as
	# the popping off of the output is another change; doubling the counts
	# might work with inotifywait, but not with the much more granular
	# polling.

	# Therefore, we need another external store to persist the counter.
	database --update "$$	${observedChanges:?}"
	[ "${DEBUG:-}" ] || trap 'database --delete $$ 2>/dev/null' EXIT

	# As with the --stop-on options, the end of observation is signaled by
	# the recursive invocation through $EXIT_SIGNAL.
	onchangeExitOnArg=(--exit-on $EXIT_SIGNAL)
    fi

    typeset -a exitStatusContinuationArgs=()
    if [ ${exitStatus:-0} -gt 0 ]; then
	# Passing the (non-zero) exit status from the last consumed line's
	# COMMAND is difficult, because onchange will periodically invoke
	# ourselves recursively, so we need to use a persisted file that we
	# clear after the first invocation.
	TMPFILE="$(mktemp --tmpdir "$(basename -- "$0")-XXXXXX" 2>/dev/null || echo "${TEMP:-/tmp}/$(basename -- "$0").$$$RANDOM")"
	printf '%d\n' "$exitStatus" > "$TMPFILE" && \
	    exitStatusContinuationArgs=(--consumed-exit-status-file "$TMPFILE")
    fi

    ONCHANGE_FILE_MARKER='' onchange "${onchangeArgs[@]}" "${onchangeExitOnArg[@]}" --bare --exec "${BASH_SOURCE[0]}" --onchange $$ "${exitStatusContinuationArgs[@]}" "${allArgs[@]}" \; "${BAG:-"${HOME}/.bag"}"
fi
